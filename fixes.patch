// === PATCH FILE: fixes.patch ===
// This file contains all changes to implement recommended improvements

// 1. Add LogRocket integration
// file: app/layout.tsx
+ import '../lib/logrocket';

// 2. Add draft history table
// file: supabase/migrations/20250912_draft_history.sql
+ create table if not exists public.draft_cakes_history (
+   id uuid primary key default gen_random_uuid(),
+   draft_id uuid references public.draft_cakes(id) on delete cascade,
+   config jsonb not null,
+   created_at timestamptz default now()
+ );
+
+ create index if not exists draft_history_draft_id_idx on public.draft_cakes_history(draft_id);

// 3. Implement caching for preview page
// file: app/preview/[id]/page.tsx
+ import { unstable_noStore as noStore, revalidateTag } from 'next/cache';
+
+ export default async function PreviewPage({ params }: { params: { id: string } }) {
+   noStore(); // отключаем кеш для актуальности
   // ... existing code
 }

// 4. Add test error endpoint
// file: app/api/test-error/route.ts
+ import * as Sentry from '@sentry/nextjs';
+
+ export async function GET() {
+   Sentry.captureException(new Error('Test Sentry error'));
+   return new Response('Error test sent', { status: 500 });
+ }

// 5. Optimize draft saving
// file: app/hooks/useOptimizedDraft.ts
+ 'use client';
+ import { useRef, useEffect } from 'react';
+ import { useDebounce } from '@/shared/hooks/useDebounce';
+
+ export function useOptimizedDraft(userId?: string) {
+   const prevConfig = useRef<string>('');
+   const debouncedConfig = useDebounce(draft?.config ?? {}, 30_000);
+
+   useEffect(() => {
+     const configStr = JSON.stringify(debouncedConfig);
+     if (configStr !== prevConfig.current) {
+       save(debouncedConfig);
+       prevConfig.current = configStr;
+     }
+   }, [debouncedConfig, userId]);
+
+   return { draft, saving, load, setDraft };
+ }

// 6. Add price calculation API
// file: app/api/price/route.ts
+ import { NextRequest, NextResponse } from 'next/server';
+ import { z } from 'zod';
+ import { calculatePrice } from '@/shared/lib/price/priceCalculator';
+
+ const PriceRequestSchema = z.object({
+   config: z.record(z.any()),
+ });
+
+ export async function POST(req: NextRequest) {
+   const body = await req.json();
+   const parsed = PriceRequestSchema.safeParse(body);
+
+   if (!parsed.success) {
+     return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
+   }
+
+   try {
+     const price = calculatePrice(parsed.data.config);
+     return NextResponse.json({ price });
+   } catch (e) {
+     return NextResponse.json({ error: 'Calculation failed' }, { status: 500 });
+   }
+ }

// 7. Add address validation
// file: components/checkout/AddressForm.tsx
+ 'use client';
+ import { useState } from 'react';
+ import { z } from 'zod';
+
+ const AddressSchema = z.object({
+   city: z.string().min(2, 'Минимум 2 символа'),
+   street: z.string().min(2, 'Минимум 2 символа'),
+   house: z.string().min(1, 'Обязательное поле'),
+ });
+
+ export function AddressForm({ onValid }: { onValid: (address: z.infer<typeof AddressSchema>) => void }) {
+   const [address, setAddress] = useState<z.infer<typeof AddressSchema>>({
+     city: '', street: '', house: ''
+   });
+   const [errors, setErrors] = useState<Record<string, string>>({});
+
+   const handleValidate = () => {
+     const result = AddressSchema.safeParse(address);
+     if (!result.success) {
+       const errs: Record<string, string> = {};
+       result.error.issues.forEach(i => {
+         errs[i.path[0] as string] = i.message;
+       });
+       setErrors(errs);
+       return;
+     }
+     onValid(result.data);
+   };
+
+   return (
+     <div className="space-y-3">
+       {/* ... input fields with error handling ... */}
+       <button onClick={handleValidate}>Проверить адрес</button>
+     </div>
+   );
+ }

// 8. Improve mobile swipe experience
// file: components/constructor/MobileLayersSwipe.tsx
+ 'use client';
+ import { useState, useRef, useEffect } from 'react';
+
+ export function MobileLayersSwipe({ layers }: { layers: Layer[] }) {
+   const [index, setIndex] = useState(0);
+   const containerRef = useRef<HTMLDivElement>(null);
+
+   useEffect(() => {
+     if (containerRef.current) {
+       containerRef.current.style.setProperty('--slide-index', String(index));
+     }
+   }, [index]);
+
+   return (
+     <div
+       ref={containerRef}
+       className="relative w-full h-64 overflow-hidden touch-pan-y"
+     >
+       <div
+         className="flex h-full transition-transform duration-300 ease-out will-change-transform"
+         style={{
+           transform: `translateX(calc(-1 * var(--slide-index) * 100%))`,
+         }}
+       >
+         {layers.map((layer) => (
+           <div key={layer.id} className="w-full flex-shrink-0 flex items-center justify-center">
+             <img
+               src={layer.imageUrl}
+               alt={layer.title}
+               className="max-h-full max-w-full object-contain select-none"
+               draggable={false}
+             />
+           </div>
+         ))}
+       </div>
+       {/* Dots navigation with accessibility */}
+     </div>
+   );
+ }
